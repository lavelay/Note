## let

- 不能重复声明
- 没有变量提升
- 不会成为顶级对象的属性
- 存在块(级)作用域
  - 写法：代码块的{} 
  - 注意：对象的{}写法与块作用域无关

```javascript
console.log(typeof a);  =>"undefined"
//在原有浏览器渲染机制下，基于typeof等逻辑运算符检测一个未被声明过的变量，不会报错
console.log(typeof a); //a is not defined;
let a;
//let解决了浏览器的暂时型死区
```



## const

- 必须设置初始值

- 不会提升

- 不会成为顶级对象属性

- 具有块作用域

- 用const声明复杂类型时，只要地址不变就可以更改内容，地址更改会报错

- 冻结对象方法:

  - Object.freeze(要冻结的对象)  将当前对象的属性冻结，无法更换值
  - 深冻结函数：

  ```javascript
  function deepFreeze(obj) {
        // 1 冻结当前对象的属性
        Object.freeze(obj);
        // 2 遍历检测，对象的属性是否也是对象
        for (var k in obj) {
          if (typeof obj[k] === 'object') {
            // 3 递归调用，进行冻结操作
            deepFreeze(obj[k]);
          }
        }
      }
  ```



## let、const、var的区别

| var        | let        | const      |
| ---------- | ---------- | ---------- |
| 函数作用域 | 块级作用域 | 块级作用域 |
| 变量提升   | 不存在提升 | 不存在提升 |
| 值可更改   | 值可更改   | 值不可更改 |



## 解构赋值

按照一定模式，从数组或对象中提取值，将提取出来的值赋值给另外的变量

- 数组结构赋值

  ```javascript
  let [变量1=默认值1, 变量2=默认值2, 变量n=默认值n] = [数组元素1, 数组元素2, 数组元素n];
  ```

  > 注：默认值是可选的，可以设置，也可以不设置；

- 对象结构赋值

  ```javascript
  let {"属性名1"：变量名1=默认值1, "属性名2"：变量名2=默认值2,... } = {"属性名1"：属性值1,"属性名2"：属性值2,...}
  ```




## 箭头函数

箭头函数不绑定this关键字，箭头函数中的this，指向的是==函数定义位置（定义作用域）的上下文this==

```javascript
var obj = {
    age : 20,
    say : () => {
        alert( this.age )
    }
}
obj.say();  // undefined  因为obj对象不能产生作用域，所以箭头函数相当于定义在全局作用域，this指向全局
```

> 形参赋值默认值：当没有给形参传递实参的时候，执行默认值

```javascript
/* function sum(n, m) {
	if (typeof n === 'undefined') {
		n = 0;
	}
	if (typeof m === 'undefined') {
		m = 0;
	}
	return n + m;
} */
let sum = (n = 0, m = 0) => n + m;
sum();
sum(10);
```

> 箭头函数中没有ARGUMENTS

```javascript
/* let sum = () => {
	console.log(arguments); //=>Uncaught ReferenceError: arguments is not defined 箭头函数中没有ARGUMENTS
}; */
// 但可以使用剩余运算符获取到传递的实参集合（数组）
let sum = (...arg) => eval(arg.join('+'));
```



## 剩余参数

"..."在ES6中有三种含义：

1. 剩余运算符
2. 拓展运算符
3. 展开运算符

```javascript
function fn (con, ...arg) {
  //con对应obj
  //arg对应[10,20,30]
  //arg是一个数组，ES5中的arguments是类数组
}
let obj = {};
fn(obj, 10, 20, 30);
```

==类数组转化为真正的数组==

1. `var array = [].slice.call(Leishuzu);`IE6~8不兼容

2. `var array = [...leishuzu]`    

3. `var array = Array.from(leishuzu) `

   ```javascript
   var array = Array.from(leishuzu, item => {
   	return item * 2;
   })
   //from第二个参数是类数组有几个参数就会调用多少次，把处理后的新数组返回
   ```

   

## 数组方法

- **findIndex**

  ```javascript
  // 数组的findIndex方法用于查找满足条件的第一个元素的索引，如果没有，则返回-1
  var arr = [10, 20, 30];
  var res1 = arr.findIndex(function (item) {
    return item >= 20;
  });
  console.log(res1);// 1
  ```

- **includes**

  ```javascript
  ary.includes('xxx') {
  	// 包含：如果存在返回的是TRUE
  }
  ```


- **find()**

  find方法接受一个函数作为参数

  ```javascript
  ary.find((item, index) => {
    return item.id == 2;
  })
  //检测数组中每一项，返回id为2的那一项
  //找不到返回undefined
  ```

map reduce every



## 字符串方法

- **repeat**


  ```javascript
  console.log("y".repeat(3)); // "yyy"
  ```

- **includes()**

  格式：`str.includes(searchString, [position])`		

  功能：返回布尔值，表示是否找到了参数字符串

  - position: 从当前字符串的哪个索引位置开始搜寻子字符串，默认值为0。

- **startsWith()**

  格式：`str.startsWidth(searchString, [position])`         

  功能：返回布尔值，表示参数字符串是否在原字符串的头部或指定位置

  - position: 在 `str` 中搜索 `searchString` 的开始位置，默认值为 0，也就是真正的字符串开头处。

- **endsWith()**

  格式：`str.endsWith(searchString, [len])`            

  功能：返回布尔值，表示参数字符串是否在原字符串的尾部或指定位置.

  - len:可选。作为 `str` 的长度。默认值为 `str.length`。





## Set数据结构

Set类似于数组，但是成员的值都是唯一的，没有重复的值

Set本身是一个构造函数，用来生成Set数据结构

`let s = new Set();`

Set函数可以接收一个数组作为参数，用来初始化

`let set = new Set([1, 2, 3, 4])`

size属性：  set.size表示set数据结构中值的个数

==实例方法==

```javascript
add(value)    // 添加某个值，返回Set结构本身
Set.add('a').add('b')  // add可以链式编写

delete(value) // 删除某个值，返回布尔值，表示是否删除成功
has(value)		// 返回布尔值，表示是否为Set成员
clear()       // 清除所有成员，没有返回值
```

***可以实现数组去重**

```javascript
let s = new Set([1, 2, 2, 3, 3]);
let ary = [...s];    //ary 为[1, 2, 3]
```

 **取值**

从Set数据结构中取值，用forEach遍历（用法和数组相比，参数不一样，Set两个参数都是元素）

 

## name是window自带属性

```javascript
let name = 'ok'
console.info(window.name) // ""
```



## 习题

```javascript
function f2(a=1,b){
	console.log(a,b,a+b);
}
f2(,3)   // 报错 Uncaught SyntaxError: Unexpected token ','
```



- 对于简单类型数据（数值、字符串、布尔值），值就保存在变量指向的那个内存单元，因此等同于常量值。

- 对于复杂类型数据（如对象和数组），变量指向的内存单元，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就不能控制了。因此，`将一个对象声明为常量必须非常小心,它的属性是可以修改的`。



## 对象的解构赋值

- 默认值是可选的。你可以指定默认值，也可以不指定。
- 右边的"属性名"与左边的“属性名” 一致，则把右边的属性值赋值给左边的变量名。
- 如果右边的匹配不成立，看看是否有使用默认值，有默认值就使用默认值，没有就是undefined。

`精简格式`

如果左侧对象中属性名与变量名相同，则可左侧合并：

```javascript
let {变量名1=默认值1，变量名2=默认值2} = {"属性名1"：属性值1,"属性名2"：属性值2,...}
```

解析规则：

- 右边的"属性名"与左边的变量名 一致，则把右边的属性值赋值给左边的变量名。

#### 闯关练习

```js

// 复杂的嵌套，只要符合模式，即可解构
let obj = {
    name: '小红',
    age: 22,
    dog: {
        name: '小明',
        gender: '男'
    }
};
// 如何才能把age和name解析出来
let {name, age, dog: {name：dogName, gender}} = obj;
console.log(name, age, dogName, gender); // '小红' 22 '小明' '男'
```



### 剩余值

```js
let name = 'zhangsan', age = 20, gender = '女';
let obj = {
    name: name, // 原来的写法
    age, // 对象属性和变量名相同，可以省略后面的 “:age”，下面的gender同理
    gender,
    fn1 : function(){  // 常规写法
        console.log(123);
    },
    fn2 () { // function可以省略 
        console.log(456);
    }
};
console.log(obj.age); // 20
obj.fn2(); // 456
```



### 传统的默认值设置方式

参数的默认值在之前的课程内容已经涉及，例如在`xhr.open(请求类型,请求地址,是否异步) `方法中，第3个参数默认是true，即表示异步ajax。

- 默认值的意思是：
  - 如果传入对应实参，就用你传的值。
  - 如果不传，就使用某个特殊的、事先定义好的值。这个值也就是默认值。
- 示例代码：（以ajax课程中的ajax函数封装为示例）

```js
// ES5 中给参数设置默认值的变通做法，以ajax函数部分封装为示例：
function ajax (type, url, isAsync) {
	// 基本写法：  
  if(isAsync === undefined){
      isAsync = true;
  }
  // 简化写法：
	// isAsync = isAsync || true;
  
  console.log(type, url, isAsync);
	//.. 其他代码略
}
// 下面这两句是等价的
open("get","common/get"); // 参数3使用默认值true
open("get","common/get",true);

open("get","common/get",false);
```

以上代码是利用了形参的一个特点：没有传入对应实参的话，其默认值是undefined。

观察后发现，代码是可以工作的，但是显得很累赘，es6提供了更简单的实现。

#### 示例

```js
function open(type, url, isAsync = true) {
    console.log(type, url, isAsync);
}
// 下面这两句是等价的
open("get","common/get")；// // 参数3使用默认值true
open("get","common/get",true);
open("get","common/get",false); 
```



### 练习

```javascript

// 与解析赋值一起使用:
function f1({a = 1, b = 2} = {}){
   console.log(a, b);
}	

f1({a:10,b:20});
f1({a:20});
f1({c:1});
f1(); // 注意：如果形参位置不设置 = {}，会出现报错

```



### 语法格式

> rest参数不能设置默认值，且必须设置在参数列表最后位置

在定义函数时，在最后一个参数前面加上`...`， 则这个参数就是剩余参数；

```javascript
let fn = function(参数1，参数2，...rest参数){}

let fn = (参数1，参数2，...rest参数) => { }; // 箭头函数具体使用，见下一小节。

```

只是在定义函数时，在形参列表中区别一下，而在调用函数时并无区别。

### 示例

回答如下问题

```javascript
function f2 (x,...y){
    console.log(x,y)
}
f2(1,2);
f2(2,3,4);

function f1 (x,y){
    console.log(x,y)
}
f1(1,2);
f1(2,3,4);

```



```javascript
function getSum (){
    //  在这里写你的代码
    var sum = 0 ; 
    for(var i = 0; i < arguments.length; i++){
        console.info( arguemnts[i])
        sum += arguments[i];
    }
}
```

如果以箭头函数 的方式去定义这个函数，则内部不可以使用arguments这个对象了。此时，我们就可以使用

rest 参数，它可以替代 arguments 的使用。 代码如下：

```js
// 参数很多，不确定多少个，可以使用剩余参数
const  getSum = (...values) => {
    var sum = 0 ; 
    for(var i = 0; i < values.length; i++){
        console.info( values[i])
        sum += values[i];
    }
}
// 调用
console.log(fn(6, 1, 100, 9, 10));

```

与arguments相比，它是一个真正的数组，可以使用全部的数组的方法。



- 注意如果返回值是一个对象，要加()

  ```js
  let f = x => { return {a:1};  }
  // 可以简化成：
  let f = x => {a:1}; // 如果不加，{}会被认为是函数的代码块，不会被解析器当成对象处理
  let f = x => ({a:1});
  ```



#### 内部的`this`对象，指向定义时所在的对象，而不是使用时所在的对象。

```js
// 箭头函数中this的问题：
let obj = {
  name: 'jack',
  age: 18,
  sayHi() {
    // 方法中直接访问this：
    console.log(this); // 对象obj
    // 普通调用的函数中的this：
    var f1 = () => {
      console.log(this); // 对象obj
    };
    f1();
    // 同上：
    setTimeout(() => {
      console.log(this); // 对象obj
    }, 0);
    // 另一个对象的方法中的this
    let obj2 = { name: 'rose' };
    obj2.sayHehe = () => {
      console.log(this); // 对象obj
    };
    obj2.sayHaha = function () {
      console.log(this); // 对象obj2，因为没有使用箭头函数
    };
    obj2.sayHehe();
    obj2.sayHaha();

  }
};
obj.sayHi();
```



#### 箭头函数不能作为构造函数

```js
let Person = () => {
	// ..代码
};
let obj = new Person(); // 报错，Person is not a constructor
// 换个角度理解，箭头函数中都没有自己的this，无法处理成员，所以不能当构造函数
```

应用3：Math.max()

```javascript
Math.max(1,3,4,6);
var arr = [1,3,4,6];
Math.max(...arr);
// 或者 Math.max.apply(this, [1, 2, 3, 566]);
```



## find方法

在实际的开发中，我们经常会遇到一种场景：从一个数组中找出符合条件的元素。我们要的讨论的重点是如何从数组中找出符合条件的元素，当然，我们可以通过手写循环的方式来实现这个功能，但是现在es6中提供了现成的功能。find/findIndex

作用：从数组中找出我们符合条件的第一个元素（或者是下标）。

### 格式

find和findIndex的格式是一致的。

```javascript
let result = [].find(function(item,index,self){ 
    //...
    // 如果满足查找的条件
    return true;
});
```

- 回调函数有三个参数，分别表示：数组元素的值、索引及整个数组
- 如果某次循环返回的是true，find和findIndex方法的返回值就是满足这个条件的第一个元素或索引

### 执行流程

- find和findIndex方法，会遍历传递进来的数组
- 如果在回调函数体内，某个时刻return true，则表示查找过程结果，返回值就是本轮循环中的元素（或者是下标）；如果全部的循环结束，也没有return true，则表示没有找到，没有找到会返回undefined。

- **findIndex** 找到数组中**第一个满足条件**的成员并**返回该成员的索引**，如果找不到返回 **-1**。

```js
let arr = [1, 2, 4, 0, -4, 3, -2, 9];
arr.find(function (item, index, self) {
    console.log(item); // 数组中的每个值
    console.log(index); // 数组中的每个索引/下标
    console.log(self); // 当前的数组
});
```

### 实践应用

从一个复杂的对象数组中找出符合条件的对象。

```javascript
let data = [
    {id:2,name:'严高',age:15},
    {id:3,name:'徐阶',age:17},
    {id:4,name:'高拱',age:18},
    {id:1,name:'张居正',age:12},
];
```



## includes()

功能：判断数组是否包含某个值，返回 true / false

格式：`数组.includes(参数1，参数2)`

- 参数1，必须，表示查找的内容
- 参数2，可选，表示开始查找的位置，0表示从第一个元素开始找。默认值是0。

示例：

```js
let arr = [1, 4, 3, 9];
console.log(arr.includes(4)); // true
console.log(arr.includes(4, 2)); // false， 从2的位置开始查，所以没有找到4
console.log(arr.includes(5)); // false
```

> ​	字符串也有这个方法，功能也是相似的。

##  ES 6 的兼容性问题 ###

- ES6 有兼容性问题，IE7-IE11 基本不支持 ES6

  [ES6 兼容性列表](http://kangax.github.io/compat-table/es6/)

- 在最新的现代浏览器、移动端、Node.js 中都支持 ES6


##  ES 6 降级处理 ###

因为 ES 6 有浏览器兼容性问题，可以使用一些工具进行降级（把ES6的代码转成ES5的代码），例如：**babel**

babel官网](https://www.babeljs.cn/)

实时转码：https://babeljs.io/repl
