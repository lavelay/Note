## let

具有块级作用域

```javascript
console.log(typeof a);  =>"undefined"
//在原有浏览器渲染机制下，基于typeof等逻辑运算符检测一个未被声明过的变量，不会报错

console.log(typeof a); //a is not defined;
let a;
//let解决了浏览器的暂时型死区
```



## const

具有块级作用域

声明常量是必须要赋予一个初始值

用const声明复杂类型时，只要地址不变就可以更改内容，地址更改会报错



## let、const、var的区别

| var        | let        | const      |
| ---------- | ---------- | ---------- |
| 函数作用域 | 块级作用域 | 块级作用域 |
| 变量提升   | 不存在提升 | 不存在提升 |
| 值可更改   | 值可更改   | 值不可更改 |



## 解构赋值

按照一定模式，从数组或对象中提取值，将提取出来的值赋值给另外的变量

- 数组结构赋值
- 对象结构赋值



## 箭头函数

箭头函数不绑定this关键字，箭头函数中的this，指向的是==函数定义位置（定义作用域）的上下文this==

```javascript
var obj = {
    age : 20,
    say : () => {
        alert( this.age )
    }
}
obj.say();  // undefined  因为obj对象不能产生作用域，所以箭头函数相当于定义在全局作用域，this指向全局
```

> 形参赋值默认值：当没有给形参传递实参的时候，执行默认值

```javascript
/* function sum(n, m) {
	if (typeof n === 'undefined') {
		n = 0;
	}
	if (typeof m === 'undefined') {
		m = 0;
	}
	return n + m;
} */
let sum = (n = 0, m = 0) => n + m;
sum();
sum(10);
```

> 箭头函数中没有ARGUMENTS

```javascript
/* let sum = () => {
	console.log(arguments); //=>Uncaught ReferenceError: arguments is not defined 箭头函数中没有ARGUMENTS
}; */
// 但可以使用剩余运算符获取到传递的实参集合（数组）
let sum = (...arg) => eval(arg.join('+'));
```



## 剩余参数

"..."在ES6中有三种含义：

1. 剩余运算符
2. 拓展运算符
3. 展开运算符

```javascript
function fn (con, ...arg) {
  //con对应obj
  //arg对应[10,20,30]
  //arg是一个数组，ES5中的arguments是类数组
}
let obj = {};
fn(obj, 10, 20, 30);
```

==类数组转化为真正的数组==

1. `var array = [].slice.call(Leishuzu);`IE6~8不兼容

2. `var array = [...leishuzu]`    

3. `var array = Array.from(leishuzu) `

   ```javascript
   var array = Array.from(leishuzu, item => {
   	return item * 2;
   })
   //from第二个参数是类数组有几个参数就会调用多少次，把处理后的新数组返回
   ```

   

## 数组方法

- **findIndex**

  ```javascript
  // 数组的findIndex方法用于查找满足条件的第一个元素的索引，如果没有，则返回-1
  var arr = [10, 20, 30];
  var res1 = arr.findIndex(function (item) {
    return item >= 20;
  });
  console.log(res1);// 1
  ```

- **includes**

  ```javascript
  ary.includes('xxx') {
  	// 包含：如果存在返回的是TRUE
  }
  ```


- **find()**

  find方法接受一个函数作为参数

  ```javascript
  ary.find((item, index) => {
    return item.id == 2;
  })
  //检测数组中每一项，返回id为2的那一项
  //找不到返回undefined
  ```



## 字符串方法

- **repeat**


  ```javascript
  console.log("y".repeat(3)); // "yyy"
  ```

- **startsWith  /  endsWith**
  - startsWith()：表示参数字符串是否在原字符串开头，返回布尔值
  - endsWith()：表示参数字符串是否在原字符串结尾，返回布尔值



## Set数据结构

Set类似于数组，但是成员的值都是唯一的，没有重复的值

Set本身是一个构造函数，用来生成Set数据结构

`let s = new Set();`

Set函数可以接收一个数组作为参数，用来初始化

`let set = new Set([1, 2, 3, 4])`

size属性：  set.size表示set数据结构中值的个数

==实例方法==

```javascript
add(value)    // 添加某个值，返回Set结构本身
Set.add('a').add('b')  // add可以链式编写

delete(value) // 删除某个值，返回布尔值，表示是否删除成功
has(value)		// 返回布尔值，表示是否为Set成员
clear()       // 清除所有成员，没有返回值
```

***可以实现数组去重**

```javascript
let s = new Set([1, 2, 2, 3, 3]);
let ary = [...s];    //ary 为[1, 2, 3]
```

 **取值**

从Set数据结构中取值，用forEach遍历（用法和数组一样）