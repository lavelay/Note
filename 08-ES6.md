## let

- 不能重复声明
- 没有变量提升
- 不会成为顶级对象的属性
- 存在块(级)作用域
  - 写法：代码块的{} 
  - 注意：对象的{}写法与块作用域无关

```javascript
console.log(typeof a);  =>"undefined"
//在原有浏览器渲染机制下，基于typeof等逻辑运算符检测一个未被声明过的变量，不会报错
console.log(typeof a); //a is not defined;
let a;
//let解决了浏览器的暂时型死区
```



## const

- 必须设置初始值

- 不会提升、不会成为顶级对象属性、具有块作用域

- 用const声明复杂类型时，只要地址不变就可以更改内容，地址更改会报错

- 冻结对象方法:

  - Object.freeze(要冻结的对象)  将当前对象的属性冻结，无法更换值
  - 深冻结函数：

  ```javascript
  function deepFreeze(obj) {
        // 1 冻结当前对象的属性
        Object.freeze(obj);
        // 2 遍历检测，对象的属性是否也是对象
        for (var k in obj) {
          if (typeof obj[k] === 'object') {
            // 3 递归调用，进行冻结操作
            deepFreeze(obj[k]);
          }
        }
      }
  ```



## let、const、var的区别

| var        | let        | const      |
| ---------- | ---------- | ---------- |
| 函数作用域 | 块级作用域 | 块级作用域 |
| 变量提升   | 不存在提升 | 不存在提升 |
| 值可更改   | 值可更改   | 值不可更改 |



## 解构赋值

按照一定模式，从数组或对象中提取值，将提取出来的值赋值给另外的变量

- 数组结构赋值

  ```javascript
  let [变量1=默认值1, 变量2=默认值2, 变量n=默认值n] = [数组元素1, 数组元素2, 数组元素n];
  ```

  > 注：默认值是可选的，可以设置，也可以不设置；

- 对象结构赋值

  ```javascript
  let {"属性名1"：变量名1=默认值1, "属性名2"：变量名2=默认值2,... } = {"属性名1"：属性值1,"属性名2"：属性值2,...}
  ```




## 箭头函数

箭头函数不绑定this关键字，箭头函数中的this，指向的是==函数定义位置（定义作用域）的上下文this==

```javascript
var obj = {
    age : 20,
    say : () => {
        alert( this.age )
    }
}
obj.say();  // undefined  因为obj对象不能产生作用域，所以箭头函数相当于定义在全局作用域，this指向全局
```

> 形参赋值默认值：当没有给形参传递实参的时候，执行默认值

```javascript
/* function sum(n, m) {
	if (typeof n === 'undefined') {
		n = 0;
	}
	if (typeof m === 'undefined') {
		m = 0;
	}
	return n + m;
} */
let sum = (n = 0, m = 0) => n + m;
sum();
sum(10);
```

> 箭头函数中没有ARGUMENTS

```javascript
/* let sum = () => {
	console.log(arguments); //=>Uncaught ReferenceError: arguments is not defined 箭头函数中没有ARGUMENTS
}; */
// 但可以使用剩余运算符获取到传递的实参集合（数组）
let sum = (...arg) => eval(arg.join('+'));
```



## 剩余参数

"..."在ES6中有三种含义：

1. 剩余运算符
2. 拓展运算符
3. 展开运算符

```javascript
function fn (con, ...arg) {
  //con对应obj
  //arg对应[10,20,30]
  //arg是一个数组，ES5中的arguments是类数组
}
let obj = {};
fn(obj, 10, 20, 30);
```

==类数组转化为真正的数组==

1. `var array = [].slice.call(Leishuzu);`IE6~8不兼容

2. `var array = [...leishuzu]`    

3. `var array = Array.from(leishuzu) `

   ```javascript
   var array = Array.from(leishuzu, item => {
   	return item * 2;
   })
   //from第二个参数是类数组有几个参数就会调用多少次，把处理后的新数组返回
   ```

   

## 数组方法

- **findIndex**

  ```javascript
  // 数组的findIndex方法用于查找满足条件的第一个元素的索引，如果没有，则返回-1
  var arr = [10, 20, 30];
  var res1 = arr.findIndex(function (item) {
    return item >= 20;
  });
  console.log(res1);// 1
  ```

- **includes**

  ```javascript
  ary.includes('xxx') {
  	// 包含：如果存在返回的是TRUE
  }
  ```


- **find()**

  find方法接受一个函数作为参数

  ```javascript
  ary.find((item, index) => {
    return item.id == 2;
  })
  //检测数组中每一项，返回id为2的那一项
  //找不到返回undefined
  ```



## 字符串方法

- **repeat**


  ```javascript
  console.log("y".repeat(3)); // "yyy"
  ```

- **includes()**

  格式：`str.includes(searchString, [position])`		

  功能：返回布尔值，表示是否找到了参数字符串

  - position: 从当前字符串的哪个索引位置开始搜寻子字符串，默认值为0。

- **startsWith()**

  格式：`str.startsWidth(searchString, [position])`         

  功能：返回布尔值，表示参数字符串是否在原字符串的头部或指定位置

  - position: 在 `str` 中搜索 `searchString` 的开始位置，默认值为 0，也就是真正的字符串开头处。

- **endsWith()**

  格式：`str.endsWith(searchString, [len])`            

  功能：返回布尔值，表示参数字符串是否在原字符串的尾部或指定位置.

  - len:可选。作为 `str` 的长度。默认值为 `str.length`。





## Set数据结构

Set类似于数组，但是成员的值都是唯一的，没有重复的值

Set本身是一个构造函数，用来生成Set数据结构

`let s = new Set();`

Set函数可以接收一个数组作为参数，用来初始化

`let set = new Set([1, 2, 3, 4])`

size属性：  set.size表示set数据结构中值的个数

==实例方法==

```javascript
add(value)    // 添加某个值，返回Set结构本身
Set.add('a').add('b')  // add可以链式编写

delete(value) // 删除某个值，返回布尔值，表示是否删除成功
has(value)		// 返回布尔值，表示是否为Set成员
clear()       // 清除所有成员，没有返回值
```

***可以实现数组去重**

```javascript
let s = new Set([1, 2, 2, 3, 3]);
let ary = [...s];    //ary 为[1, 2, 3]
```

 **取值**

从Set数据结构中取值，用forEach遍历（用法和数组一样）

 

### 题5

```
console.log(a); 
var a = 1; 
let b = 2;
let name = 'ok'
console.info(a,b)
console.info(window.a)
console.info(window.b)
console.info(window.name) 
```



### 题1

```js
let { name, age,address='1' } = {age: 27, name: '阳明'};
console.log(name, age,address); 
```

### 题2

```js
let {b, name:a} = {name: '王阳明'};
console.log(b, a, name); 
```

### 题3

```
let { name='a', age,address='1' } = {};
console.log(name, age,address); 
```

### 题4

```
let obj = {
    name: 'zhangsan',
    age: 22,
    dog: {
        name: '毛毛',
        age: 3
    }
};
// 下面写一句代码，把 zhangsan '毛毛' 解析出来
//  你的代码
console.log(name, name1); // zhangsan '毛毛'
```



### 题5

```
let response = {
    data: ['a', 'b', 'c'],
    meta: {
        code: 200,
        msg: '获取数据成功'
    }
}
// 如何获取到 code 和 msg
// 你的代码

console.log(code, d); // 200, 'b'
```



### 题6

```js
let obj = {name:'zs', age:20, gender:'男'};
let {age, ...a} = obj;
console.log(age, a);
```



## 函数

### 题1

```javascript
function f(a=1,b=2){
	console.log(a,b,a+b);
}
f(10)
f(10,20)
f()

```

### 题2

```
function f2(a=1,b){
	console.log(a,b,a+b);
}
f2(10)
f2(10,20)
f2(,3)
f2()


```

### 题3

```
function f1({a=1,b=2}={}){
   console.log(a,b,a+b);
}

f1({a:10,b:20})
f1({a:20})
f1({c:1})
f1()
```

### 题4

```
function f2 (x,...y){
    console.log(x,y)
}
f2(1,2);
f2(2,3,4);
```

### 题5

```
function f1 (x,y){
    console.log(x,y)
}
f1(1,2);
f1(2,3,4);
```



### 题6

用箭头函数对下列函数进行改写

```
function f1(x){
	console.log(x)
}

function f2(x,y){
	return x + y
}

function f3(x,y){
	return {a:x,b:x+y}
}
```

### 题7

如下代码的输出

```js
var name = 'a'; 
let obj = {
    name: 'b',
    f1 : () => {
        console.log(this);
        console.log(this.name); 
    },
    f2 : function(){
        console.log(this); 
        console.log(this.name); 
    }
};
obj.f1();
obj.f2();
```





##  数组

### 题1

```
let arr1 = [1,2,3];
let arr2 = [...arr1];
console.log(arr2);
```



### 题2

```javascript
var arr0 = ['a','b'];
var arr1 = [1,2,3];
var arr2 = [4, ...arr1];
var arr3 = [..arr0 ,...arr1];
console.log(arr2,arr3);
```

### 题3

```javascript
var arr = [1,3,4,6];
// 使用Math.min求最小值
// var min = ?
console.info(min);// 1
```

### 题4

从一个复杂的对象数组中找出符合条件的对象。

```javascript
let data = [
    {id:2,name:'严嵩',age:15},
    {id:3,name:'徐阶',age:17},
    {id:4,name:'高拱',age:18},
    {id:1,name:'张居正',age:12},
]
// 使用find找出‘高拱’的age,注意使用箭头函数来简化代码
```

### 题5

```javascript
let arr = [1,1,2,3,3];
// 一句代码实现数组去重
// let arr1 = ?
console.info(arr1); // [1,2,3]
```



- 对于简单类型数据（数值、字符串、布尔值），值就保存在变量指向的那个内存单元，因此等同于常量值。

- 对于复杂类型数据（如对象和数组），变量指向的内存单元，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就不能控制了。因此，`将一个对象声明为常量必须非常小心,它的属性是可以修改的`。


如果你真的希望**定义一个不能修改的对象**（属性不能添加，修改，删除），你可以使用Object.freeze()。下面是一段参考代码：它一个可以把一个对象全部冻结的函数（深冻结）:

```javascript
// 设置函数，对一个对象进行深冻结(用于防止复杂数据被修改)
function deepFreeze(obj) {
  Object.freeze(obj);
  for (var k in obj) {
    if (typeof obj[k] === 'object') {
      deepFreeze(obj[k]);
    }
  }
}

// 声明要冻结的对象
const obj = {
  name: 'jack',
  age: 18,
  hobbies: {
    eat: '吃',
    drink: '喝',
    run: '跑步',
    playBall: ['篮球', '弹球', '悠悠球']
  }
};

// 调用函数冻结对象obj
deepFreeze(obj);
obj.name = 'rose';
obj.hobbies.eat = '各种吃';
obj.hobbies.playBall[2] = '各种弹';
console.log(obj); // obj没有变化，说明冻结完成
```



## 对象的解构赋值

作用：快速从对象中获取值保存到变量中。它的本质是给变量赋值。

- 默认值是可选的。你可以指定默认值，也可以不指定。
- 右边的"属性名"与左边的“属性名” 一致，则把右边的属性值赋值给左边的变量名。
- 如果右边的匹配不成立，看看是否有使用默认值，有默认值就使用默认值，没有就是undefined。

`精简格式`

如果左侧对象中属性名与变量名相同，则可左侧合并：

```javascript
let {变量名1=默认值1，变量名2=默认值2} = {"属性名1"：属性值1,"属性名2"：属性值2,...}
```

解析规则：

- 右边的"属性名"与左边的变量名 一致，则把右边的属性值赋值给左边的变量名。



### 基本使用

场景1，变量名和属性名一样

```js
// 场景1，默认要求变量名和属性名一样
let { name, age } = {age: 27, name: 'jack'};
console.log(name, age); // 'jack' 27

let {a, c} = {a: 'hello', b: 'world'};
console.log(a, c); // 'hello' undefined
```

注意：

- “=” 左右两边的格式一致。
- 对象是属性的无序集合，所以不需要管顺序

场景2，变量改名

```js
// 场景2，可以通过:为变量改名
let {b, name:a} = {name: '李雷'};
console.log(b, a, name); // undefined '李雷' undefined
// 解释：操作中，将属性name的值保存给变量a，所以只有a有值
```

#### 闯关练习

```js
// 默认值:
var {b=1, name:a,age:b=20 } = {name: '韩梅梅'};
console.log(b, a, name); // 2 '韩梅梅' undefined


// 复杂的嵌套，只要符合模式，即可解构
let obj = {
    name: '小红',
    age: 22,
    dog: {
        name: '小明',
        gender: '男'
    }
};
// 如何才能把age和name解析出来
let {name, age, dog: {name：dogName, gender}} = obj;
console.log(name, age, dogName, gender); // '小红' 22 '小明' '男'


// 假设从服务器上获取的数据如下
let response = {
    data: ['a', 'b', 'c'],
    meta: {
        code: 200,
        msg: '获取数据成功'
    }
}
// 如何获取到 code 和 msg
let { meta: { code, msg } } = response;
console.log(code, msg); // 200 '获取数据成功'


let {max,min,PI} = Math;
```



### 剩余值

```js
// 把其它的属性全收集起来
let obj = {name:'zs', age:20, gender:'男'};
let {name, ...a} = obj;
console.log(name, a);
// 结果：
// name = zs
// a = {age: 20, gender: "男"};
```



```js
let name = 'zhangsan', age = 20, gender = '女';
let obj = {
    name: name, // 原来的写法
    age, // 对象属性和变量名相同，可以省略后面的 “:age”，下面的gender同理
    gender,
    fn1 : function(){  // 常规写法
        console.log(123);
    },
    fn2 () { // function可以省略 
        console.log(456);
    }
};
console.log(obj.age); // 20
obj.fn2(); // 456
```



### 传统的默认值设置方式

参数的默认值在之前的课程内容已经涉及，例如在`xhr.open(请求类型,请求地址,是否异步) `方法中，第3个参数默认是true，即表示异步ajax。

- 默认值的意思是：
  - 如果传入对应实参，就用你传的值。
  - 如果不传，就使用某个特殊的、事先定义好的值。这个值也就是默认值。
- 示例代码：（以ajax课程中的ajax函数封装为示例）

```js
// ES5 中给参数设置默认值的变通做法，以ajax函数部分封装为示例：
function ajax (type, url, isAsync) {
	// 基本写法：  
  if(isAsync === undefined){
      isAsync = true;
  }
  // 简化写法：
	// isAsync = isAsync || true;
  
  console.log(type, url, isAsync);
	//.. 其他代码略
}
// 下面这两句是等价的
open("get","common/get"); // 参数3使用默认值true
open("get","common/get",true);

open("get","common/get",false);
```

以上代码是利用了形参的一个特点：没有传入对应实参的话，其默认值是undefined。

观察后发现，代码是可以工作的，但是显得很累赘，es6提供了更简单的实现。

#### 示例

```js
function open(type, url, isAsync = true) {
    console.log(type, url, isAsync);
}
// 下面这两句是等价的
open("get","common/get")；// // 参数3使用默认值true
open("get","common/get",true);

open("get","common/get",false); 

```



### 练习

```javascript
function f(a = 1,b = 2){
	console.log(a, b);
}
f(10);
f(10,20);
f();

function f2(a = 1,b){
	console.log(a, b);
}
f2(10);
f2(10,20);
f2(,3); // 报错：Uncaught SyntaxError: Unexpected token
f2(); 

// 与解析赋值一起使用:
function f1({a = 1, b = 2} = {}){
   console.log(a, b);
}	

f1({a:10,b:20});
f1({a:20});
f1({c:1});
f1(); // 注意：如果形参位置不设置 = {}，会出现报错

```



### 语法格式

> rest参数不能设置默认值，且必须设置在参数列表最后位置

在定义函数时，在最后一个参数前面加上`...`， 则这个参数就是剩余参数；

```javascript
let fn = function(参数1，参数2，...rest参数){}

let fn = (参数1，参数2，...rest参数) => { }; // 箭头函数具体使用，见下一小节。

```

只是在定义函数时，在形参列表中区别一下，而在调用函数时并无区别。

### 示例

回答如下问题

```javascript
function f2 (x,...y){
    console.log(x,y)
}
f2(1,2);
f2(2,3,4);

function f1 (x,y){
    console.log(x,y)
}
f1(1,2);
f1(2,3,4);

```

### 应用--代替arguments

问题：编写一个函数，求所有参数之和；

方法一：arguments

方法二：rest参数

```javascript
function getSum (){
    //  在这里写你的代码
    var sum = 0 ; 
    for(var i = 0; i < arguments.length; i++){
        console.info( arguemnts[i])
        sum += arguments[i];
    }
}
```

如果以箭头函数 的方式去定义这个函数，则内部不可以使用arguments这个对象了。此时，我们就可以使用

rest 参数，它可以替代 arguments 的使用。 代码如下：

```js
// 参数很多，不确定多少个，可以使用剩余参数
const  getSum = (...values) => {
    var sum = 0 ; 
    for(var i = 0; i < values.length; i++){
        console.info( values[i])
        sum += values[i];
    }
}
// 调用
console.log(fn(6, 1, 100, 9, 10));

```

与arguments相比，它是一个真正的数组，可以使用全部的数组的方法。



### 简化写法

- 当函数体只有一条语句，并且就是return语句，则可以省略return和大括号。

  - 如果省略了大括号，则必须省略return，否则报错

  ```js
  let f = x => {return x*2; }
  // 可以简化成：
  let f = x => x*2;
  ```
  
- 注意如果返回值是一个对象，要加()

  ```js
  let f = x => { return {a:1};  }
  // 可以简化成：
  let f = x => {a:1}; // 如果不加，{}会被认为是函数的代码块，不会被解析器当成对象处理
  let f = x => ({a:1});
  ```



#### 内部的`this`对象，指向定义时所在的对象，而不是使用时所在的对象。

```js
// 箭头函数中this的问题：
let obj = {
  name: 'jack',
  age: 18,
  sayHi() {
    // 方法中直接访问this：
    console.log(this); // 对象obj

    // 普通调用的函数中的this：
    var f1 = () => {
      console.log(this); // 对象obj
    };
    f1();

    // 同上：
    setTimeout(() => {
      console.log(this); // 对象obj
    }, 0);

    // 另一个对象的方法中的this
    let obj2 = { name: 'rose' };
    obj2.sayHehe = () => {
      console.log(this); // 对象obj
    };
    obj2.sayHaha = function () {
      console.log(this); // 对象obj2，因为没有使用箭头函数
    };
    obj2.sayHehe();
    obj2.sayHaha();

  }
};
obj.sayHi();

```



#### 箭头函数不能作为构造函数

```js
let Person = () => {
	// ..代码
};
let obj = new Person(); // 报错，Person is not a constructor
// 换个角度理解，箭头函数中都没有自己的this，无法处理成员，所以不能当构造函数

```

在javascript中，函数的功能太多了，除了起到最基本的封装代码之外，还可以当做构造器来使用。ES6中提出的箭头函数让函数减负了，只适合代码的封装操作。



##  数组的扩展

## 扩展运算符

功能：它的作用是把数组中的元素一项项地展开：把一个整体的数组拆开成单个的元素。

格式：`...数组`

基本用法

```javascript
console.log(...[1,2,3]);
```

应用1：数组拷贝

应用2： 数组合并

从把一个数组中的值全取出来，放在另一个数组中的

```javascript
var arr0 = ['a', 'b'];
var arr1 = [1, 2, 3];
var arr2 = [4, ...arr1];
var arr3 = [..arr0, ...arr1];
```

应用3：Math.max()

```javascript
Math.max(1,3,4,6);
var arr = [1,3,4,6];
Math.max(...arr);
// 或者 Math.max.apply(this, [1, 2, 3, 566]);
```

## Array.from()

功能：把其它伪数组的对象转成数组。

格式： `数组 = Array.from(伪数组对象)`

它的实参有三种情况：

1. 自定义的，类似数组格式的对象。

```js
let fakeArr = {
  0: 'a',
  1: 'b',
  2: 'c',
  length: 3
};
```

就是为了演示，并无实际应用价值。

2. arguments对象
3. DOM 操作返回的 NodeList 集合

## find方法

在实际的开发中，我们经常会遇到一种场景：从一个数组中找出符合条件的元素。我们要的讨论的重点是如何从数组中找出符合条件的元素，当然，我们可以通过手写循环的方式来实现这个功能，但是现在es6中提供了现成的功能。find/findIndex

作用：从数组中找出我们符合条件的第一个元素（或者是下标）。

### 格式

find和findIndex的格式是一致的。

```javascript
let result = [].find(function(item,index,self){ 
    //...
    // 如果满足查找的条件
    return true;
});

```

- 回调函数有三个参数，分别表示：数组元素的值、索引及整个数组
- 如果某次循环返回的是true，find和findIndex方法的返回值就是满足这个条件的第一个元素或索引

### 执行流程

- find和findIndex方法，会遍历传递进来的数组
- 如果在回调函数体内，某个时刻return true，则表示查找过程结果，返回值就是本轮循环中的元素（或者是下标）；如果全部的循环结束，也没有return true，则表示没有找到，没有找到会返回undefined。

- **findIndex** 找到数组中**第一个满足条件**的成员并**返回该成员的索引**，如果找不到返回 **-1**。

```js
let arr = [1, 2, 4, 0, -4, 3, -2, 9];
arr.find(function (item, index, self) {
    console.log(item); // 数组中的每个值
    console.log(index); // 数组中的每个索引/下标
    console.log(self); // 当前的数组
});

```

### 简单示例

```js
// 用法：找数组中第一个小于0的数字
let arr = [1, 2, 4, 0, -4, 3, -2, 9];
let result = arr.find(function (item) {
    return item < 0; //遍历过程中，根据这个条件去查找
});
console.log(result); // -4

```

注意通过箭头函数来简化代码。

### 实践应用

从一个复杂的对象数组中找出符合条件的对象。

```javascript
let data = [
    {id:2,name:'严高',age:15},
    {id:3,name:'徐阶',age:17},
    {id:4,name:'高拱',age:18},
    {id:1,name:'张居正',age:12},
];

```



## includes()

功能：判断数组是否包含某个值，返回 true / false

格式：`数组.includes(参数1，参数2)`

- 参数1，必须，表示查找的内容
- 参数2，可选，表示开始查找的位置，0表示从第一个元素开始找。默认值是0。

示例：

```js
let arr = [1, 4, 3, 9];
console.log(arr.includes(4)); // true
console.log(arr.includes(4, 2)); // false， 从2的位置开始查，所以没有找到4
console.log(arr.includes(5)); // false

```

> ​	字符串也有这个方法，功能也是相似的。

##  ES 6 的兼容性问题 ###

- ES6 有兼容性问题，IE7-IE11 基本不支持 ES6

  [ES6 兼容性列表](http://kangax.github.io/compat-table/es6/)

- 在最新的现代浏览器、移动端、Node.js 中都支持 ES6


##  ES 6 降级处理 ###

因为 ES 6 有浏览器兼容性问题，可以使用一些工具进行降级（把ES6的代码转成ES5的代码），例如：**babel**

babel官网](https://www.babeljs.cn/)

实时转码：https://babeljs.io/repl



## 对象的解构赋值

- 基本使用
  - 其他使用（属性左右不对应的情况，没有找到取值默认undefined）
- 设置属性别名
  - let {username: un} = {username: 'jack'};
- 设置默认值
  - let {username = 'jack'} = {age : 18};
- 设置剩余值的保存
  - let {age, ...qiTa} = {age: 21, gender: '女', aiHao: '吃'};
    - qiTa的取值为 {gender: '女', aiHao: '吃'}

## 对象的简写方式

- 属性的简写

  - 前提：要设置的属性名需要与保存值的变量名相同

- 方法的简写

  ```javascript
  var username = 'jack';
  var userAge = 18;
  var obj = {
    username,
    userAge,
    sayHi: function () { // 以前的写法
      // ...
    },
    sayHehe() { // 简写
      // ...
    }
  };
  ```



## 函数参数的默认值

- 设置方式：在函数的形参位置书写   形参名 = 默认值  的形式
- 函数的形参也可以结合解构赋值使用

## 函数参数的剩余值

- 设置方式：  在某个形参前书写...， 位置为最后，用来获取剩余的所有实参
- 比arguments好的地方：剩余值的结果是数组，不是伪数组。可以与其他参数分开获取。

## 箭头函数

- 作用：用来对匿名函数写法进行简化
- 设置方式:  (参数位置) => { 函数体 }
- 参数的使用：
  - 无参数和多于1个的参数必须加()设置参数
  - 单个参数可以不加()
  - 小结：分不清，全加即可
- 返回值的使用
  - 如果函数体中只需要设置返回值，不写=>后面的{}和return
  - 其他情况全加即可
  - 小结：分不清，全加即可

- 箭头函数中的this问题
  - 箭头函数中没有单独的this，this值取决于箭头函数所在的环境
  - 如果设置匿名函数时，没用this，可以直接使用箭头函数
